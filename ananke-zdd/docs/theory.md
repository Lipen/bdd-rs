# Theory & Fundamentals

## Core Concepts

### Families of Sets

A **family** F is a collection of sets. For example:

```
F = {{}, {1}, {3}, {1, 3}, {2, 3}}
```

This is the fundamental object that ZDDs represent. Unlike a single set (which BDDs represent directly as truth assignments), families are richer:

- A family can contain many sets
- A family can be empty (no sets)
- A family can contain the empty set

**Notation**:

- ⊥ (bottom/false): empty family containing zero sets
- ⊤ (top/true): family containing only the empty set {∅}
- F ∪ G: union of families (combine all sets)
- F ∩ G: intersection (only common sets)
- F ⊗ G: join (all unions S ∪ T where S ∈ F, T ∈ G)

### The Zero-Suppression Rule

**Definition**: A ZDD node is eliminated if its `hi` edge points to ⊥.

**Why this specific rule?** In set representation:

- The `hi` edge represents "all sets containing this variable"
- If there are NO sets containing a variable, `hi = ⊥`
- Therefore, the node is useless: the lo branch already captures everything

**Contrast with BDD**: BDDs eliminate nodes where `lo = hi` (the node is useless because both branches are identical). ZDDs use a different criterion optimized for sparse set families.

### Level and Variable Ordering

Variables have a **total ordering** v₀ < v₁ < ... < vₙ. Each variable vᵢ appears at a unique **level** in the ZDD.

**Invariant**: In any path from root to terminal, variables appear in increasing order.

This ensures:

- Uniqueness (given a fixed ordering, each family has one ZDD)
- Efficient node lookup (all vᵢ nodes are at the same level)
- Fast operations (can compare levels to navigate)

### Terminals

Two special nodes:

1. **⊥ (ZERO)**: Represents the empty family ∅
   - No paths from input lead here
   - Used as `hi` edge for variables not in any set

2. **⊤ (ONE)**: Represents the family {∅}
   - The only path is the empty path
   - Reached by going `lo` at every decision

**Key insight**: If you reach ⊤, you've successfully "collected" one set. If you go `hi` at a level, you've added that variable to the current set.

## Operations on ZDDs

All operations recursively traverse the DAG, combining results via the Shannon expansion:

### Shannon Expansion

For any function f and variable v:

```
f = v̄ · f|_{v=0} + v · f|_{v=1}
```

In ZDD terms:

```
F = {sets not containing v} ∪ {v} ∪ {sets containing v}
```

Where:

- `{sets not containing v}` corresponds to the `lo` branch
- `{v} ∪ {sets containing v}` corresponds to the `hi` branch (add v to all sets)

### Union: F ∪ G

```rust
union(⊥, g) = g
union(f, ⊥) = f
union(⊤, ⊤) = ⊤
union(f.lo, g.lo) ∪ (f.hi ∪ g.hi)
```

**Intuition**: A set is in the union if it's in either family. Recursively merge both branches.

**Complexity**: O(|F| × |G|) where |·| is the number of nodes.

### Intersection: F ∩ G

```rust
inter(⊥, g) = ⊥
inter(f, ⊥) = ⊥
inter(⊤, ⊤) = ⊤
inter(⊤, g) = ⊤ if empty set in g, else ⊥
inter(f, ⊤) = ⊤ if empty set in f, else ⊥
```

**Intuition**: A set is in the intersection only if it's in both families. Follow lo branches when variables differ (no overlap); recurse on matching branches.

### Join: F ⊗ G

The join operation computes: {S ∪ T | S ∈ F, T ∈ G}

```rust
join(⊥, g) = ⊥
join(f, ⊥) = ⊥
join(⊤, ⊤) = ⊤
join(⊤, g) = g
join(f, ⊤) = f
```

For non-terminals with the same variable v:

```
join(f, g) = v: join(f.lo, g.lo) | join(f.hi, g.lo) | join(f.lo, g.hi) | join(f.hi, g.hi)
```

But the key optimization:

```
lo_branch = join(f.lo, g.lo)           // Neither has v
hi_branch = union(join(f.hi, g.lo), join(f.lo, g.hi), join(f.hi, g.hi))
                                        // At least one has v
```

**Example**:

```
join({{1}}, {{2}}) = {{1,2}}
join({{1}, {3}}, {{2}}) = {{1,2}, {3,2}}
```

**Why this matters**: Join is the fundamental operation for combinatorial generation. All $k$-element subsets are generated by joining $k$ singleton families.

### Subset1: Extract with Variable

`subset1(F, v)` returns all sets containing `v`, but with `v` removed.

```rust
subset1(⊥, v) = ⊥
subset1(⊤, v) = ⊥  // Empty set doesn't contain v
```

For non-terminals:

```
if v is higher level (earlier): subset1(F.lo, v) ∪ subset1(F.hi, v)  // Look lower
if v matches: F.hi  // Sets with v, need v removed
if v is lower level (later): ⊥  // v can't be in these sets
```

**Use case**: Filtering and constraint application.

### Change: Toggle Variables

`change(F, v)` toggles v in all sets:

- If S ∈ F and v ∉ S, result has S ∪ {v}
- If S ∈ F and v ∈ S, result has S \ {v}

```rust
change(⊥, v) = ⊥
change(⊤, v) = {{v}}
```

## Complexity Bounds

### Worst Case

For n variables, the worst-case ZDD size is O(2^n). Example: if every subset is in your family, you need 2^n nodes to represent all of them.

However:

### Typical Cases

**Sparse families** (the ZDD sweet spot):

- Combinatorial: $C(n, k)$ representable in $O(n^2)$ nodes
- Graph problems: Paths/cuts/cliques often $O(n^3)$
- Constraint satisfaction: Depends on constraint structure

**Dense families** (ZDDs struggle):

- Representing all subsets: Still $O(2^n)$ (unavoidable)
- Most practical problems: Not this bad

The intuition: **ZDDs are exponentially faster than naive enumeration for sparse families**, but there's no free lunch—you still pay for the family's inherent complexity.

## Variable Ordering

**Critical**: The variable ordering dramatically affects ZDD size.

**Good ordering** (for N-Queens):

- Group by row: (row 0, col 0), (row 0, col 1), ..., (row 1, col 0), ...
- Exploit locality: conflicts happen between nearby rows

**Bad ordering**:

- Random: no structure
- Result: Large intermediate nodes

**Heuristic**: Order variables to maximize locality in the problem domain.

---

Next: [Operations deep-dive →](operations.md)
