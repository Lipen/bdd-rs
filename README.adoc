= Ananke: Decision Diagrams for Rust

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

image:https://github.com/Lipen/bdd-rs/actions/workflows/ci.yml/badge.svg?branch=master["CI",link="https://github.com/Lipen/bdd-rs/actions"]
image:https://hitsofcode.com/github/Lipen/bdd-rs["Hits-of-Code",link="https://hitsofcode.com/view/github/Lipen/bdd-rs"]

Ananke is a collection of Decision Diagram (DD) libraries for Rust, focused on formal verification, static analysis, and symbolic logic research.

== Engines

Core engines for different symbolic representations:

* *link:ananke-bdd/[ananke-bdd]*: Binary Decision Diagrams (ROBDDs) with complement edges.
* *link:ananke-zdd/[ananke-zdd]*: Zero-suppressed Decision Diagrams for sparse sets and combinatorial problems.
* *link:ananke-sdd/[ananke-sdd]*: Sentential Decision Diagrams for succinct representation of complex knowledge bases.

== Case Studies

Symbolic algorithms and analysis frameworks:

* *link:examples/abstract-interpretation/[Abstract Interpretation]*: Static program analysis using BDDs to represent numeric and symbolic domains.
* *link:examples/model-checking/[Symbolic Model Checking]*: CTL verification algorithms (EX, EF, AG, etc.) for large state spaces.
* *link:examples/symbolic-execution/[Symbolic Execution]*: Path-sensitive analysis for Boolean programs with counterexample generation.

== Research

Explorations in Boolean function theory and testing:

* *link:examples/tbdd-pbt/[Theory-aware BDD-guided PBT]*: Integrating BDDs with property-based testing to handle domain-specific constraints.
* *link:examples/cig/[Canonical Interaction Graphs (CIG)]*: Analyzing structural properties of Boolean functions via interaction graphs.
* *link:examples/boolean-functions/[Boolean Function Space]*: Analysis and visualization of the Boolean function space.
* *link:examples/expr-space/[Symbolic Expression Space]*: Symbolic representation and manipulation of Boolean expression tree spaces.

== Quick Start

[source,rust]
----
use ananke_bdd::bdd::Bdd;

let bdd = Bdd::default();
let x1 = bdd.mk_var(1);
let x2 = bdd.mk_var(2);

// f = x1 ∧ ¬x2
let f = bdd.apply_and(x1, -x2);

assert!(!bdd.is_zero(f)); // Satisfiable
println!("f = {}", bdd.to_bracket_string(f)); // f = ~@3:(x1, @2:(x2, ⊤, ⊥), ⊤)
----

.Installation Details
[%collapsible]
====
Add the desired engine to your `Cargo.toml`:

[source,toml]
----
[dependencies]
ananke-bdd = "0.1"
# or ananke-zdd, ananke-sdd
----

For research examples, clone the repository and run via cargo:
[source,bash]
----
git clone https://github.com/Lipen/bdd-rs
cd bdd-rs
cargo run -p model-checking --example mutex
----
====

== Documentation

* *Guides*: Tutorials for link:docs/guide/[BDDs], link:examples/abstract-interpretation/guide/[Abstract Interpretation], and link:examples/model-checking/guide/[Model Checking].
    - image:https://img.shields.io/badge/Guide-Binary Decision Diagrams-blue?style=social&logo=gitbook["Comprehensive Guide on BDDs", link="https://lipen.github.io/bdd-rs/guide-bdd.pdf"]
    - image:https://img.shields.io/badge/Guide-Abstract Interpretation-blue?style=social&logo=gitbook["Guide on Abstract Interpretation", link="https://lipen.github.io/bdd-rs/guide-ai.pdf"]
    - image:https://img.shields.io/badge/Guide-Model Checking-blue?style=social&logo=gitbook["Guide on Model Checking", link="https://lipen.github.io/bdd-rs/guide-mc.pdf"]
* *API*: Run `cargo doc --no-deps` for the full reference.
* *Examples*: Each crate and case study includes a `README` and runnable examples.

== Performance

The implementation uses hash-consing, operation caching, and 32-bit node handles to manage large state spaces efficiently.

TIP: Always use `--release` mode!

== License

This project is licensed under the link:LICENSE[MIT License].
